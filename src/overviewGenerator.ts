import fs from 'fs';
import path from 'path';
import ignore from 'ignore';
import { readGitignore, isIgnored } from './fileUtils.js';
import { ALWAYS_IGNORE, ASTROLARK_MARKER } from './constants.js';

interface FilterRule {
  type: 'include' | 'exclude';
  path: string;
}

export function generateOverview(
  rootPath: string,
  filterRules: FilterRule[] = [{ type: 'include', path: '.' }]
): {
  content: string;
  ignoredFiles: Map<string, string[]>;
} {
  const gitignorePatterns = readGitignore(rootPath);
  const ig = ignore().add(gitignorePatterns).add(ALWAYS_IGNORE);
  let structure: string[] = [];
  let files: { [key: string]: string } = {};
  let ignoredFiles: Map<string, string[]> = new Map();

  // Normalize filter paths
  const normalizedFilterRules = filterRules.map(rule => ({
    type: rule.type,
    path: path.isAbsolute(rule.path) ? path.relative(rootPath, rule.path) : rule.path
  }));

  function isIncluded(relativePath: string): boolean {
    let included = false;
    for (const rule of normalizedFilterRules) {
      if (relativePath === rule.path || relativePath.startsWith(rule.path + path.sep) || rule.path === '.') {
        included = rule.type === 'include';
      }
    }
    return included;
  }

  function traverseDirectory(dir: string, depth: number = 0): void {
    const filesInDir = fs.readdirSync(dir);
    filesInDir.forEach((file, index) => {
      const filePath = path.join(dir, file);
      const relativePath = path.relative(rootPath, filePath);

      // First, check if the file is ignored by .gitignore
      if (isIgnored(filePath, rootPath, ig)) {
        ignoredFiles.set(relativePath, ['ignored by .gitignore']);
        return;
      }

      // Then, check if the file/directory is included based on the filter rules
      if (!isIncluded(relativePath)) {
        ignoredFiles.set(relativePath, ['excluded by filter rules']);
        return;
      }

      const isLast = index === filesInDir.length - 1;
      const prefix = '  '.repeat(depth) + (isLast ? '└─ ' : '├─ ');
      structure.push(`${prefix}${file}`);

      if (fs.statSync(filePath).isDirectory()) {
        traverseDirectory(filePath, depth + 1);
      } else {
        const content = fs.readFileSync(filePath, 'utf-8');
        files[relativePath] = content;
      }
    });
  }

  // Start traversal from the root path
  traverseDirectory(rootPath);

  // Generate META-INFO content
  const metaInfo = `@@ALK<META-INFO>
ABOUT_ASTROLARK_FILE: This file was generated by Astrolark - a tool for copying parts of a repository including path and other metadata in a format friendly to provide LLMs.
BASE_PATH: ${rootPath}
FILTER_RULES: ${JSON.stringify(normalizedFilterRules)}
STRUCTURE:
${structure.join('\n')}
@@ALK</META-INFO>
`;

  // Generate Astrolark format content
  let content = `# ${ASTROLARK_MARKER}\n\n`;
  content += metaInfo + '\n';

  for (const [filePath, fileContent] of Object.entries(files)) {
    content += `@@ALK<FILE path="${filePath}">\n${fileContent}\n@@ALK</FILE>\n\n`;
  }

  return { content, ignoredFiles };
}
