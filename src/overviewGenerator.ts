import fs from 'fs';
import path from 'path';
import ignore from 'ignore';
import { readGitignore, isIgnored } from './fileUtils.js';
import { ALWAYS_IGNORE, ASTROLARK_MARKER } from './constants.js';

export function generateOverview(rootPath: string, filterPaths: string[] = ['.']): {
  content: string,
  ignoredFiles: Map<string, string[]>
} {
  const gitignorePatterns = readGitignore(rootPath);
  const ig = ignore().add(gitignorePatterns).add(ALWAYS_IGNORE);
  let structure: string[] = [];
  let files: { [key: string]: string } = {};
  let ignoredFiles: Map<string, string[]> = new Map();

  // Normalize filter paths
  const normalizedFilterPaths = filterPaths.map(filterPath =>
    path.isAbsolute(filterPath) ? path.relative(rootPath, filterPath) : filterPath
  );

  // Check for child paths
  for (let i = 0; i < normalizedFilterPaths.length; i++) {
    for (let j = i + 1; j < normalizedFilterPaths.length; j++) {
      if (normalizedFilterPaths[j].startsWith(normalizedFilterPaths[i] + path.sep)) {
        console.warn(`Warning: Path "${normalizedFilterPaths[j]}" is a child of "${normalizedFilterPaths[i]}"`);
      }
    }
  }

  function traverseDirectory(dir: string, depth: number = 0): void {
    const filesInDir = fs.readdirSync(dir);
    filesInDir.forEach((file, index) => {
      const filePath = path.join(dir, file);
      const relativePath = path.relative(rootPath, filePath);

      // First, check if the file is ignored
      if (isIgnored(filePath, rootPath, ig)) {
        ignoredFiles.set(relativePath, ['ignored']);
        return;
      }

      // Then, check if the file/directory is in the filter list
      const isInFilterList = normalizedFilterPaths.some(filterPath =>
        relativePath === filterPath || relativePath.startsWith(filterPath + path.sep) || filterPath === '.'
      );

      if (!isInFilterList) {
        ignoredFiles.set(relativePath, ['not in filter list']);
        return;
      }

      const isLast = index === filesInDir.length - 1;
      const prefix = '  '.repeat(depth) + (isLast ? '└─ ' : '├─ ');
      structure.push(`${prefix}${file}`);

      if (fs.statSync(filePath).isDirectory()) {
        traverseDirectory(filePath, depth + 1);
      } else {
        const content = fs.readFileSync(filePath, 'utf-8');
        files[relativePath] = content;
      }
    });
  }

  // Start traversal from each filter path
  normalizedFilterPaths.forEach(filterPath => {
    const fullPath = path.join(rootPath, filterPath);
    if (fs.existsSync(fullPath)) {
      if (fs.statSync(fullPath).isDirectory()) {
        traverseDirectory(fullPath);
      } else {
        const relativePath = path.relative(rootPath, fullPath);
        if (!isIgnored(fullPath, rootPath, ig)) {
          const content = fs.readFileSync(fullPath, 'utf-8');
          files[relativePath] = content;
          structure.push(relativePath);
        } else {
          ignoredFiles.set(relativePath, ['ignored']);
        }
      }
    } else {
      throw new Error(`Filter path not found: ${fullPath}`);
    }
  });

  // Generate META-INFO content
  const metaInfo = `@@ALK<META-INFO>\nABOUT_ASTROLARK: This file was generated by Astrolark.\nBASE_PATH: ${rootPath}\nSTRUCTURE:\n${structure.join('\n')}\n@@ALK</META-INFO>\n`;

  // Generate Astrolark format content
  let content = `# ${ASTROLARK_MARKER}\n\n`;
  content += metaInfo + '\n';

  for (const [filePath, fileContent] of Object.entries(files)) {
    content += `@@ALK<FILE path="${filePath}">\n${fileContent}\n@@ALK</FILE>\n\n`;
  }

  return { content, ignoredFiles };
}
